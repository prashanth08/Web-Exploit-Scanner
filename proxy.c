// ******************************* INFORMATION ***************************//

// ***********************************************************************//
//  
// ** NAME - Web exploit scanner
// ** 
// ** @pb476 - Prashanth Basappa
// ** @12/5/2014
// ** @access - DCN CS5434 project - Cornell University - private
// 
//      
// ***********************************************************************//

// ********************************** START ******************************//  
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>
#include <errno.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "proxy.h"
#define DEBUG


int main(int argc, char **argv)
{
	pid_t chpid;
	struct sockaddr_in addr_in, cli_addr, serv_addr;
	struct hostent *hostent;
	int sockfd, newsockfd;
	int clilen = sizeof(cli_addr);
	struct stat st = {0};
	FILE *fp;
	fp = fopen("notmalicious.html","w");
	char *source=NULL;
	if(argc != 2)
	{
		printf("Using:\n\t%s <port>\n", argv[0]);
		return -1;
	}
  
	printf("starting...\n");
	if (stat("./cache/", &st) == -1) {
		mkdir("./cache/", 0700);
	}
   
	bzero((char*)&serv_addr, sizeof(serv_addr));
	bzero((char*)&cli_addr, sizeof(cli_addr));
	   
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(atoi(argv[1]));
	serv_addr.sin_addr.s_addr = INADDR_ANY;
   
	// creating the listening socket for our proxy server
	sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(sockfd < 0)
	{
		perror("failed to initialize socket");
	}
   
	// binding our socket to the given port
	if(bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
	{
		perror("failed to bind socket");
	}
	listen(sockfd, 50);

// ======================================================================= // 
// ! Accept NEW connections                                               //        
// =======================================================================//  
	
accepting:
	newsockfd = accept(sockfd, (struct sockaddr*)&cli_addr, &clilen);
	
	if((chpid = fork()) == 0)
	{
		struct sockaddr_in host_addr,vm_addr;
		int i, n;			
		int rsockfd;		
		int cfd;int vmfd;					
		int port = 80;	
		int m;		
		char type[256];		
		char url[4096];		
		char proto[256];
		char datetime[256];	
		char url_host[256], url_path[256];		
		char url_encoded[4096];	
		char filepath[256]; 
		char *dateptr;		
		char buffer[4096];char vm_buf[4096];char buf[4096];	
		int response_code;			
		bzero((char*)buffer, 4096);			
		recv(newsockfd, buffer, 4096, 0);
		sscanf(buffer, "%s %s %s", type, url, proto);
		if(url[0] == '/')
		{
			strcpy(buffer, &url[1]);
			strcpy(url, buffer);
		}
		
#ifdef DEBUG
		printf("-> %s %s %s\n", type, url, proto);
#endif
		if((strncmp(type , "GET", 3) != 0) || ((strncmp(proto, "HTTP/1.1", 8) != 0) && (strncmp(proto, "HTTP/1.0", 8) != 0)))
		{
#ifdef DEBUG
			printf("\t-> bad request format - we only accept HTTP GETs\n");
#endif
			sprintf(buffer,"400 : BAD REQUEST\nONLY GET REQUESTS ARE ALLOWED");
			send(newsockfd, buffer, strlen(buffer), 0);
			goto end;
		}
		parse_url(url, url_host, &port, url_path);
		url_encode(url, url_encoded);
		
#ifdef DEBUG
		printf("\t-> url_host: %s\n", url_host);
		printf("\t-> port: %d\n", port);
#endif
		
		if((hostent = gethostbyname(url_host)) == NULL)
		{
			fprintf(stderr, "failed to resolve %s: %s\n", url_host, strerror(errno));
			goto end;
		}
		
		bzero((char*)&host_addr, sizeof(host_addr));
		host_addr.sin_port = htons(port);
		host_addr.sin_family = AF_INET;
		bcopy((char*)hostent->h_addr, (char*)&host_addr.sin_addr.s_addr, hostent->h_length);

		// create a socket to connect to the remote host
		rsockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		
		if(rsockfd < 0)
		{
			perror("failed to create remote socket");
			goto end;
		}
				
		// try connecting to the remote host
		if(connect(rsockfd, (struct sockaddr*)&host_addr, sizeof(struct sockaddr)) < 0)
		{
			perror("failed to connect to remote server");
			goto end;
		}

#ifdef DEBUG		
		printf("\t-> connected to host: %s w/ ip: %s\n", url_host, inet_ntoa(host_addr.sin_addr));
#endif
		sprintf(filepath, "./cache/%s", url_encoded);
		if (0 != access(filepath, 0)) {
			sprintf(buffer,"GET %s HTTP/1.0\r\nHost: %s\r\nConnection: close\r\n\r\n", url_path, url_host);
#ifdef DEBUG		
			printf("\t-> first access...\n");
#endif
			goto request; 
		}
		sprintf(filepath, "./cache/%s", url_encoded);
		cfd = open (filepath, O_RDWR);
		bzero((char*)buffer, 4096);
		read(cfd, buffer, 4096);
		close(cfd);
		dateptr = strstr(buffer, "Date:");
		if(NULL != dateptr)
		{
			// response has a Date field, like Date: Fri, 18 Apr 2014 02:57:20 GMT
			
			bzero((char*)datetime, 256);
			strncpy(datetime, &dateptr[6], 29);
			sprintf(buffer,"GET %s HTTP/1.0\r\nHost: %s\r\nIf-Modified-Since: %s\r\nConnection: close\r\n\r\n", url_path, url_host, datetime);
#ifdef DEBUG		
			printf("\t-> conditional GET...\n");
			printf("\t-> If-Modified-Since: %s\n", datetime);
#endif
		} else {
			// generally all http responses have Date filed, but just in case!
			sprintf(buffer,"GET %s HTTP/1.0\r\nHost: %s\r\nConnection: close\r\n\r\n", url_path, url_host);
#ifdef DEBUG		
			printf("\t-> the response had no date field\n");
#endif
		}

request:
		n = send(rsockfd, buffer, strlen(buffer), 0);
		
		if(n < 0)
		{
			perror("failed to write to remote socket");
			goto end;
		}
		// =======================================================================// 
		// ! START CACHING HERE                      						       //        
		// =======================================================================//  

do_cache:


		cfd = -1;
		do
		{
			bzero((char*)buffer, 4096);

			n = recv(rsockfd, buffer, 4096, 0);
			if(n > 0)
			{
				if(cfd == -1)
				{
					float ver;
					sscanf(buffer, "HTTP/%f %d", &ver, &response_code);
					
#ifdef DEBUG		
					printf("\t-> response_code: %d\n", response_code);
#endif
					// if it is not 304 -- anything other than sub-CASE32
					if(response_code != 304)
					{
						sprintf(filepath, "./cache/%s", url_encoded);
						if((cfd = open(filepath, O_RDWR|O_TRUNC|O_CREAT, S_IRWXU)) < 0)
						{
							perror("failed to create cache file");
							goto end;
						}
#ifdef DEBUG		
						//printf("\t-> from remote host...\n");
#endif
					} else {

#ifdef DEBUG


#endif
						goto from_cache;
					}
				}

				write(cfd, buffer, n);
			}
		} while(n > 0);
		close(cfd);
from_cache:
		sprintf(filepath, "./cache/%s", url_encoded);
		if((cfd = open (filepath, O_RDONLY)) < 0)
		{
			perror("failed to open cache file");
			goto end;
		}
		do
		{
				bzero( (void*)&vm_addr, sizeof(vm_addr));
				bzero((char*)buffer, 4096);
				n = read(cfd, buffer, 4096);
				if(n > 0)
				{
					// send it to the browser
					if(fp!=NULL){	
					if(fseek(fp,0L,SEEK_END) ==0){
						fwrite(buffer,1,n,fp);
					}}

					printf("\n First attempt to connect to the remote VM");
					fflush(stdout);

					vm_addr.sin_family = AF_INET;
					vm_addr.sin_port = htons(5600);
					vm_addr.sin_addr.s_addr = inet_addr("192.168.99.151");

					if((vmfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
							
							printf("\n VM socket error.");
							perror("Error: ");
							fflush(stderr);
							fflush(stdout);
							exit(1);
					}

					printf("\n Trying to connect to VM");

					if( (connect(vmfd, (struct sockaddr*)&vm_addr, sizeof(vm_addr))) < 0) {

							printf("\n Connect to vm failed.");
							perror("Error: ");
							break;
							fflush(stdout);
							fflush(stderr);
							exit(errno);
					}
					printf("\n Connected to vm\n");
					printf("%s\n",buffer );
							send(vmfd,buffer, strlen(buffer), 0);
							sleep(1);			
			}
			char* end = strstr(buffer,"</html>");
			if(end!=NULL){
			break;
				}
		} while(n > 0); 
		m = read(vmfd, vm_buf, 13);
		printf("m=%d\n",m );
		vm_buf[13]='\0';
		//printf("%s\n\n",vm_buf);
		if(m==9 ){
						FILE *fp2 = fopen("malicious.html","rb");
			if(fp2!=NULL){
				if(fseek(fp2,0L,SEEK_END)==0){
					long bufsize=ftell(fp2);
					if(bufsize == -1){printf("BUFFER ERROR\n");}
					source = malloc(sizeof(char) * (bufsize+1));
					if(fseek(fp2,0L,SEEK_SET)!=0){printf("SEEK ERROR\n");}
					size_t newlen = fread(source,sizeof(char),bufsize,fp2);
					if(newlen==0){printf("ERROR reading file\n");}
					else {
						source[++newlen] = '\0';
					}
				}
								
			}
			free(source);
			fclose(fp2);
			}
			else {
			FILE *fp1 = fopen("notmalicious.html","rb");
			if(fp1!=NULL){
				if(fseek(fp1,0L,SEEK_END)==0){
					long bufsize=ftell(fp1);
					if(bufsize == -1){printf("BUFFER ERROR\n");}
					source = malloc(sizeof(char) * (bufsize+1));
					if(fseek(fp1,0L,SEEK_SET)!=0){printf("SEEK ERROR\n");}
					size_t newlen = fread(source,sizeof(char),bufsize,fp1);
					if(newlen==0){printf("ERROR reading file\n");}
					else {
						source[++newlen] = '\0';
					}
				}
				
				
			}
			free(source);
			fclose(fp1);
			} 
			send(newsockfd, source, strlen(source), 0);
		
		close(cfd);

end:
#ifdef DEBUG

#endif
		close(rsockfd);
		close(newsockfd);
		close(sockfd);
		return 0;
	} else {

		close(newsockfd);
		goto accepting;
	}
	
	close(sockfd);
	return 0;

}

//Referneces:
//http://stackoverflow.com/questions/2029103/correct-way-to-read-a-text-file-into-a-buffer-in-c
//http://superuser.com/questions/117913/ps-aux-output-meaning
//http://www.binarytides.com/linux-ps-command/
//http://unix.stackexchange.com/questions/106847/what-does-aux-mean-in-ps-aux
//http://askubuntu.com/questions/360252/what-do-the-stat-column-values-in-ps-mean
//https://www.daniweb.com/software-development/c/threads/325624/program-that-will-open-a-web-browser
//discussed the design of the project with kg399,am383
